#include "templates.h"

#include <preludec/mem/str.h>


static inline void stream_write_str(stream *io, str s) {
  assert(io != NULL);

  iostatus status = {};
  stream_write(io, make_const_span(s.data, s.length * sizeof(char)), &status);
  assert_release(status != IO_STATUS_ERROR);
}


void write_header_prelude(stream *io) {
  assert(io != NULL);

  stream_write_str(io, str_literal(
    "// Generated by sqlgen, do not edit.\n\n"

    "#pragma once\n\n"

    "#include <sqlite3.h>\n"
    "#include <preludec/defs.h>\n"
    "#include <preludec/mem/span.h>\n"
    "#include <preludec/mem/str.h>\n\n\n"


    "typedef RESULT(UNIT, str) sql_result;\n\n"

    "typedef struct sql_iterator sql_iterator;\n"
    "struct sql_iterator {\n"
    "  void (*next)(void *udata, sqlite3_stmt *stmt);\n\n"

    "  void *udata;\n"
    "};\n\n"

    "#define SQL_NOITER  ((sql_iterator){ .next = NULL, .udata = NULL })\n\n\n"
  ));
}


void write_source_prelude(stream *io) {
  assert(io != NULL);

  stream_write_str(io, str_literal(
    "// Generated by sqlgen, do not edit.\n\n"

    "#include <generated/sql.h>\n\n\n"
  ));
}


static str map_typename(str type) {
  if (str_equal(type, str_literal("INTEGER"))) {
    return str_literal("sqlite3_int64");
  }
  else if (str_equal(type, str_literal("REAL"))) {
    return str_literal("f64");
  }
  else if (str_equal(type, str_literal("TEXT"))) {
    return str_literal("str");
  }
  else if (str_equal(type, str_literal("BLOB"))) {
    return str_literal("const_span");
  }
  else {
    return type;
  }
}


static str map_binder(str type) {
  if (str_equal(type, str_literal("INTEGER"))) {
    return str_literal("sqlite3_bind_int64");
  }
  else if (str_equal(type, str_literal("REAL"))) {
    return str_literal("sqlite3_bind_double");
  }
  else if (str_equal(type, str_literal("TEXT"))) {
    return str_literal("sqlite3_bind_text");
  }
  else if (str_equal(type, str_literal("BLOB"))) {
    return str_literal("sqlite3_bind_blob");
  }
  else {
    return str_literal("sqlite3_bind_null");
  }
}


static void write_signature(stream *io, str proc_name, VEC(sql_param) params) {
  assert(io != NULL);

  stream_write_str(io, str_literal("sql_result sql__"));
  stream_write_str(io, proc_name);
  stream_write_str(io, str_literal(
    "(\n"
    "  sqlite3      *db,\n"
    "  sql_iterator  it"
  ));

  if (params.count > 0) {
    stream_write_str(io, str_literal(",\n\n  "));

    for (usize i = 0; i < params.count; ++i) {
      if (i > 0) {
        stream_write_str(io, str_literal(",\n  "));
      }

      stream_write_str(io, map_typename(params.data[i].type));
      stream_write_str(io, str_literal(" "));
      stream_write_str(io, params.data[i].name);
    }
  }

  stream_write_str(io, str_literal("\n)"));
}


void write_prototype(stream *io, str proc_name, VEC(sql_param) params) {
  assert(io != NULL);

  write_signature(io, proc_name, params);

  stream_write_str(io, str_literal(";\n\n"));
}


void write_implementation(stream *io, str proc_name, VEC(sql_param) params, const char *input_path) {
  assert(io         != NULL);
  assert(input_path != NULL);

  write_signature(io, proc_name, params);

  stream_write_str(io, str_literal(
    " {\n"
    "  assert(db != NULL);\n\n"

    "  static constexpr char query_data[] = {\n"
    "    #embed \""
  ));

  stream_write_str(io, strview_from_cstr(input_path));

  stream_write_str(io, str_literal(
    "\"\n"
    "  };\n"

    "  static constexpr usize query_size = ARRAY_COUNT(query_data);\n"
    "  static const     str   query      = {\n"
    "    .data     = (char*)query_data,\n"
    "    .length   = query_size,\n"
    "    .capacity = query_size,\n"
    "    .owned    = false,\n"
    "  };\n\n"

    "  str next = query;\n\n"

    "  while(true) {\n"
    "    const char   *tail = NULL;\n"
    "    sqlite3_stmt *stmt = NULL;\n"
    "    int           res  = sqlite3_prepare(db, next.data, (int)next.length, &stmt, &tail);\n"
    "    if (res != SQLITE_OK) {\n"
    "      return (RESULT(UNIT, str)) ERR(strview_from_cstr(sqlite3_errstr(res)));\n"
    "    }\n\n"

    "    if (stmt == NULL) {\n"
    "      break;\n"
    "    }\n\n"
  ));

  if (params.count > 0) {
    stream_write_str(io, str_literal("    int param_idx = 0;\n\n"));

    for (usize i = 0; i < params.count; ++i) {
      stream_write_str(io, str_literal(
        "    param_idx = sqlite3_bind_parameter_index(stmt, \""
      ));

      stream_write_str(io, params.data[i].name);

      stream_write_str(io, str_literal(
        "\");\n"
        "    if (param_idx != 0) {\n"
        "      res = "
      ));

      stream_write_str(io, map_binder(params.data[i].type));
      stream_write_str(io, str_literal("(stmt, param_idx, "));
      stream_write_str(io, params.data[i].name);

      if (str_equal(params.data[i].type, str_literal("TEXT"))) {
        stream_write_str(io, str_literal(".data, (int)"));
        stream_write_str(io, params.data[i].name);
        stream_write_str(io, str_literal(".length, SQLITE_STATIC"));
      }
      else if (str_equal(params.data[i].type, str_literal("BLOB"))) {
        stream_write_str(io, str_literal(".data, (int)"));
        stream_write_str(io, params.data[i].name);
        stream_write_str(io, str_literal(".size, SQLITE_STATIC"));
      }

      stream_write_str(io, str_literal(
        ");\n"
        "      if (res != SQLITE_OK) {\n"
        "        assert_release(SQLITE_OK == sqlite3_finalize(stmt));\n"
        "        return (RESULT(UNIT, str)) ERR(strview_from_cstr(sqlite3_errstr(res)));\n"
        "      }\n"
        "    }\n\n"
      ));
    }
  }

  stream_write_str(io, str_literal(
    "    while(true) {\n"
    "      res = sqlite3_step(stmt);\n"
    "      if (res == SQLITE_ROW) {\n"
    "        if (it.next != NULL) it.next(it.udata, stmt);\n"
    "      }\n"
    "      else if (res == SQLITE_DONE) {\n"
    "        break;\n"
    "      }\n"
    "      else {\n"
    "        assert_release(SQLITE_OK == sqlite3_finalize(stmt));\n"
    "        return (RESULT(UNIT, str)) ERR(strview_from_cstr(sqlite3_errstr(res)));\n"
    "      }\n"
    "    }\n\n"

    "    assert_release(SQLITE_OK == sqlite3_finalize(stmt));\n\n"

    "    next = str_slice(\n"
    "      query,\n"
    "      (usize)(tail - query.data),\n"
    "      query.length\n"
    "    );\n"
    "  }\n\n"

    "  return (RESULT(UNIT, str)) OK({});\n"
    "}\n\n"
  ));
}
